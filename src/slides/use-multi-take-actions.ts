import { useFrame } from '@react-three/fiber'
import { useMemo } from 'react'
import { AnimationAction, AnimationClip, AnimationMixer, Group, KeyframeTrack } from 'three'
import { subclip } from 'three/src/animation/AnimationUtils'


interface AnimationActions {
  [id: string]: AnimationAction
}

interface Props {
  animations: AnimationClip[]
  fps?:       number
  padding?:   [number, number]
  root:       Group | null
}

/**
 * Works around a problem I found with animations generated by a designer who used what he describes as a "multi-take"
 * animation approach. I found that animations would have long leading and trailing gaps. To fix that, `makeAction`
 * finds the start and end frames of the animation and creates a new clip to play only those frames.
 */
export function useMultiTakeAnimations(props: Props): AnimationActions {
  const { animations, fps, padding = [0, 0], root } = props

  const info = useMemo(() => {
    return root ? setup(root) : { mixer: null, actions: {} }

    function setup(root: Group): { actions: AnimationActions, mixer: AnimationMixer } {
      const mixer = new AnimationMixer(root)

      const actions: AnimationActions = {}
      animations.forEach((clip) => {
        actions[clip.name] = makeAction({ clip, fps, mixer, padding })
      })

      return { actions, mixer }
    }
  }, [root, fps, padding[0], padding[1]])

  useFrame((_, delta) => {
    const { mixer } = info
    mixer?.update(delta)
  })

  return info.actions
}

interface ActionProps {
  clip:     AnimationClip
  fps?:     number
  mixer:    AnimationMixer
  padding?: [number, number]
}

function makeAction(props: ActionProps): AnimationAction {
  const { clip, fps = 30, mixer, padding = [0, 0] } = props
  const { tracks, name } = clip

  const start = Math.max(0, getStartFrame() + padding[0])
  const end = getEndFrame() + padding[1]
  const sub = subclip(clip, name, start, end)
  return mixer.clipAction(sub)

  function getStartFrame(): number {
    return Math.floor(Math.min(...tracks.map(getTrackStart)) * fps)

    function getTrackStart(track: KeyframeTrack): number {
      return Math.min(...track.times)
    }
  }

  function getEndFrame(): number {
    return Math.ceil(Math.max(...tracks.map(getTrackEnd)) * fps)

    function getTrackEnd(track: KeyframeTrack): number {
      return Math.max(...track.times)
    }
  }
}
